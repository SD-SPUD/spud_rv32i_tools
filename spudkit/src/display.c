#include "display.h"
#include "spudkit.h"
#ifdef UART_DISPLAY
#include "uart.h"
#endif

// Conditional macros for display output - switch between SIM and UART modes
#ifdef UART_DISPLAY
    #define DISPLAY_PUTS(str)           uart_puts(str)
    #define DISPLAY_PUTC(ch)            uart_putc(ch)
    #define DISPLAY_PUT_HEX16(val)      uart_put_hex16(val)
    #define DISPLAY_CURSOR_HOME()       uart_cursor_home()
    #define DISPLAY_CLEAR_SCREEN()      uart_clear_screen()
    #define DISPLAY_SET_COLOR(fg, bg)   uart_set_color(fg, bg)
    #define DISPLAY_RESET_COLOR()       uart_reset_color()
    #define DISPLAY_RGB565_TO_ANSI(rgb) uart_rgb565_to_ansi(rgb)
#elif defined(SIM_DISPLAY)
    #define DISPLAY_PUTS(str)           sim_puts(str)
    #define DISPLAY_PUTC(ch)            sim_putc(ch)
    #define DISPLAY_PUT_HEX16(val)      sim_put_hex16(val)
    #define DISPLAY_CURSOR_HOME()       sim_cursor_home()
    #define DISPLAY_CLEAR_SCREEN()      sim_clear_screen()
    #define DISPLAY_SET_COLOR(fg, bg)   sim_set_color(fg, bg)
    #define DISPLAY_RESET_COLOR()       sim_reset_color()
    #define DISPLAY_RGB565_TO_ANSI(rgb) sim_rgb565_to_ansi(rgb)
#else
    // No display output - stub functions
    #define DISPLAY_PUTS(str)
    #define DISPLAY_PUTC(ch)
    #define DISPLAY_PUT_HEX16(val)
    #define DISPLAY_CURSOR_HOME()
    #define DISPLAY_CLEAR_SCREEN()
    #define DISPLAY_SET_COLOR(fg, bg)
    #define DISPLAY_RESET_COLOR()
    #define DISPLAY_RGB565_TO_ANSI(rgb) 0
#endif

// frame buffer - stores the entire display in memory
static spud_color_t framebuffer[DISPLAY_HEIGHT][DISPLAY_WIDTH];

// display functions for both SIM_DISPLAY and UART_DISPLAY modes
#if defined(SIM_DISPLAY) || defined(UART_DISPLAY)

void display_sim_print_pixel(uint8_t x, uint8_t y, spud_color_t color) {
    DISPLAY_PUTS("PIXEL(");
    DISPLAY_PUT_HEX16(x);
    DISPLAY_PUTC(',');
    DISPLAY_PUT_HEX16(y);
    DISPLAY_PUTS(")=0x");
    DISPLAY_PUT_HEX16(color);
    DISPLAY_PUTS("\r\n");
}

void display_sim_print_buffer(void) {
    // move cursor to top-left to redraw over previous display
    DISPLAY_CURSOR_HOME();

    // draw top border
    DISPLAY_RESET_COLOR();
    DISPLAY_PUTS("┌");
    for(int x = 0; x < DISPLAY_WIDTH; x++) {
        DISPLAY_PUTS("─");
    }
    DISPLAY_PUTS("┐\r\n");

    // draw the 64x64 display with half-height blocks (2 pixels per character)
    for(int y = 0; y < DISPLAY_HEIGHT; y += 2) {
        DISPLAY_RESET_COLOR();
        DISPLAY_PUTS("│"); // left border

        for(int x = 0; x < DISPLAY_WIDTH; x++) {
            spud_color_t top_pixel = framebuffer[y][x];
            spud_color_t bottom_pixel = (y + 1 < DISPLAY_HEIGHT) ? framebuffer[y + 1][x] : COLOR_BLACK;

            if(top_pixel == COLOR_BLACK && bottom_pixel == COLOR_BLACK) {
                // both pixels black - use space
                DISPLAY_RESET_COLOR();
                DISPLAY_PUTS(" ");
            } else if(top_pixel != COLOR_BLACK && bottom_pixel == COLOR_BLACK) {
                // top pixel colored, bottom black - upper half block
                uint8_t ansi_color = DISPLAY_RGB565_TO_ANSI(top_pixel);
                DISPLAY_SET_COLOR(ansi_color, 16); // colored fg, black bg
                DISPLAY_PUTS("▀");
                DISPLAY_RESET_COLOR();
            } else if(top_pixel == COLOR_BLACK && bottom_pixel != COLOR_BLACK) {
                // top black, bottom colored - lower half block
                uint8_t ansi_color = DISPLAY_RGB565_TO_ANSI(bottom_pixel);
                DISPLAY_SET_COLOR(ansi_color, 16); // colored fg, black bg
                DISPLAY_PUTS("▄");
                DISPLAY_RESET_COLOR();
            } else {
                // both pixels colored
                uint8_t top_color = DISPLAY_RGB565_TO_ANSI(top_pixel);
                uint8_t bottom_color = DISPLAY_RGB565_TO_ANSI(bottom_pixel);
                DISPLAY_SET_COLOR(top_color, bottom_color); // top as fg, bottom as bg
                DISPLAY_PUTS("▀");
                DISPLAY_RESET_COLOR();
            }
        }

        DISPLAY_RESET_COLOR();
        DISPLAY_PUTS("│\r\n"); // Right border and newline
    }

    // Draw bottom border
    DISPLAY_RESET_COLOR();
    DISPLAY_PUTS("└");
    for(int x = 0; x < DISPLAY_WIDTH; x++) {
        DISPLAY_PUTS("─");
    }
    DISPLAY_PUTS("┘\r\n");

    DISPLAY_RESET_COLOR();
}

#endif

void display_init(void) {
    // initialize framebuffer to black
    mem_set(framebuffer, 0, sizeof(framebuffer));

#if defined(SIM_DISPLAY) || defined(UART_DISPLAY)
    DISPLAY_CLEAR_SCREEN();
    #ifdef UART_DISPLAY
    DISPLAY_PUTS("DISPLAY_INIT: UART display mode enabled - Visual Terminal Display\r\n");
    #else
    DISPLAY_PUTS("DISPLAY_INIT: Simulation mode enabled - Visual Terminal Display\r\n");
    #endif
    DISPLAY_PUTS("Display size: 64x64 pixels\r\n\r\n");
#else
    // todo: initialize actual 64x64 matrix display hardware
    // this will involve setting up the display controller registers
    // at SPUD_DISPLAY_BASE when hardware is implemented
#endif
}

void display_clear(spud_color_t color) {
    for(int y = 0; y < DISPLAY_HEIGHT; y++) {
        for(int x = 0; x < DISPLAY_WIDTH; x++) {
            framebuffer[y][x] = color;
        }
    }

#if defined(SIM_DISPLAY) || defined(UART_DISPLAY)
    DISPLAY_PUTS("DISPLAY_CLEAR: color=0x");
    DISPLAY_PUT_HEX16(color);
    DISPLAY_PUTS("\r\n");
#endif
}

void display_set_pixel(uint8_t x, uint8_t y, spud_color_t color) {
    if(x >= DISPLAY_WIDTH || y >= DISPLAY_HEIGHT) return;

    framebuffer[y][x] = color;

#if defined(SIM_DISPLAY) || defined(UART_DISPLAY)
    // display_sim_print_pixel(x, y, color);
#endif
}

void display_update_pixel(uint8_t x, uint8_t y, spud_color_t color) {
    if(x >= DISPLAY_WIDTH || y >= DISPLAY_HEIGHT) return;

    framebuffer[y][x] = color;

#if defined(SIM_DISPLAY) || defined(UART_DISPLAY)
    // For simulation, we can't update individual pixels without redrawing
    // Just update framebuffer, will be shown on next display_update()
#else
    // Update single pixel on hardware display
    volatile uint32_t* display_data_reg = (volatile uint32_t*)SPUD_DISPLAY_PIXEL_DATA_REG;
    volatile uint32_t* display_addr_reg = (volatile uint32_t*)SPUD_DISPLAY_PIXEL_ADDR_REG;

    uint16_t pixel_addr = y * DISPLAY_WIDTH + x;

    // color is already in RGB888 format for real hardware, no conversion needed
    *display_addr_reg = pixel_addr;
    *display_data_reg = color;
#endif
}

spud_color_t display_get_pixel(uint8_t x, uint8_t y) {
    if(x >= DISPLAY_WIDTH || y >= DISPLAY_HEIGHT) return COLOR_BLACK;
    return framebuffer[y][x];
}

void display_draw_line(uint8_t x0, uint8_t y0, uint8_t x1, uint8_t y1, spud_color_t color) {
    // Bresenham's line algorithm
    int dx = x1 > x0 ? x1 - x0 : x0 - x1;
    int dy = y1 > y0 ? y1 - y0 : y0 - y1;
    int sx = x0 < x1 ? 1 : -1;
    int sy = y0 < y1 ? 1 : -1;
    int err = dx - dy;

    while(1) {
        display_set_pixel(x0, y0, color);

        if(x0 == x1 && y0 == y1) break;

        int e2 = 2 * err;
        if(e2 > -dy) {
            err -= dy;
            x0 += sx;
        }
        if(e2 < dx) {
            err += dx;
            y0 += sy;
        }
    }
}

void display_draw_rect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, spud_color_t color) {
    // Draw rectangle outline
    display_draw_line(x, y, x + width - 1, y, color);                    // Top
    display_draw_line(x, y + height - 1, x + width - 1, y + height - 1, color); // Bottom
    display_draw_line(x, y, x, y + height - 1, color);                  // Left
    display_draw_line(x + width - 1, y, x + width - 1, y + height - 1, color);  // Right
}

void display_fill_rect(uint8_t x, uint8_t y, uint8_t width, uint8_t height, spud_color_t color) {
    for(uint8_t py = y; py < y + height && py < DISPLAY_HEIGHT; py++) {
        for(uint8_t px = x; px < x + width && px < DISPLAY_WIDTH; px++) {
            display_set_pixel(px, py, color);
        }
    }
}

void display_draw_circle(uint8_t cx, uint8_t cy, uint8_t radius, spud_color_t color) {
    // Bresenham's circle algorithm
    int x = 0;
    int y = radius;
    int d = 3 - 2 * radius;

    while(y >= x) {
        // Draw 8 symmetrical points
        display_set_pixel(cx + x, cy + y, color);
        display_set_pixel(cx - x, cy + y, color);
        display_set_pixel(cx + x, cy - y, color);
        display_set_pixel(cx - x, cy - y, color);
        display_set_pixel(cx + y, cy + x, color);
        display_set_pixel(cx - y, cy + x, color);
        display_set_pixel(cx + y, cy - x, color);
        display_set_pixel(cx - y, cy - x, color);

        x++;
        if(d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
    }
}

// Compact 4x6 font (all printable ASCII characters 32-126)
// Each character is 4 bits wide, 6 rows tall
static const uint8_t font_4x6[96][6] = {
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, // 32: Space
    {0x4, 0x4, 0x4, 0x4, 0x0, 0x4}, // 33: !
    {0xA, 0xA, 0x0, 0x0, 0x0, 0x0}, // 34: "
    {0xA, 0xF, 0xA, 0xF, 0xA, 0x0}, // 35: #
    {0x4, 0xF, 0x6, 0xC, 0xF, 0x4}, // 36: $
    {0x3, 0x8, 0x4, 0x2, 0xC, 0x0}, // 37: %
    {0x6, 0x9, 0x6, 0xA, 0x9, 0x6}, // 38: &
    {0x4, 0x4, 0x0, 0x0, 0x0, 0x0}, // 39: '
    {0x4, 0x2, 0x2, 0x2, 0x4, 0x0}, // 40: (
    {0x2, 0x4, 0x4, 0x4, 0x2, 0x0}, // 41: )
    {0x0, 0xA, 0x4, 0xA, 0x0, 0x0}, // 42: *
    {0x0, 0x4, 0xE, 0x4, 0x0, 0x0}, // 43: +
    {0x0, 0x0, 0x0, 0x0, 0x4, 0x2}, // 44: ,
    {0x0, 0x0, 0xE, 0x0, 0x0, 0x0}, // 45: -
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x4}, // 46: .
    {0x8, 0x4, 0x4, 0x2, 0x2, 0x1}, // 47: /
    {0x6, 0x9, 0xB, 0xD, 0x9, 0x6}, // 48: 0
    {0x4, 0x6, 0x4, 0x4, 0x4, 0xE}, // 49: 1
    {0x6, 0x9, 0x8, 0x6, 0x1, 0xF}, // 50: 2
    {0x6, 0x9, 0x4, 0x8, 0x9, 0x6}, // 51: 3
    {0x8, 0xA, 0xA, 0xF, 0x8, 0x8}, // 52: 4
    {0xF, 0x1, 0x7, 0x8, 0x9, 0x6}, // 53: 5
    {0x6, 0x1, 0x7, 0x9, 0x9, 0x6}, // 54: 6
    {0xF, 0x8, 0x4, 0x2, 0x2, 0x2}, // 55: 7
    {0x6, 0x9, 0x6, 0x9, 0x9, 0x6}, // 56: 8
    {0x6, 0x9, 0x9, 0xE, 0x8, 0x6}, // 57: 9
    {0x0, 0x4, 0x0, 0x4, 0x0, 0x0}, // 58: :
    {0x0, 0x4, 0x0, 0x4, 0x2, 0x0}, // 59: ;
    {0x8, 0x4, 0x2, 0x4, 0x8, 0x0}, // 60: <
    {0x0, 0xE, 0x0, 0xE, 0x0, 0x0}, // 61: =
    {0x1, 0x2, 0x4, 0x2, 0x1, 0x0}, // 62: >
    {0x6, 0x9, 0x4, 0x4, 0x0, 0x4}, // 63: ?
    {0x6, 0x9, 0xD, 0xD, 0x1, 0x6}, // 64: @
    {0x6, 0x9, 0x9, 0xF, 0x9, 0x9}, // 65: A
    {0x7, 0x9, 0x7, 0x9, 0x9, 0x7}, // 66: B
    {0x6, 0x9, 0x1, 0x1, 0x9, 0x6}, // 67: C
    {0x7, 0x9, 0x9, 0x9, 0x9, 0x7}, // 68: D
    {0xF, 0x1, 0x7, 0x1, 0x1, 0xF}, // 69: E
    {0xF, 0x1, 0x7, 0x1, 0x1, 0x1}, // 70: F
    {0x6, 0x9, 0x1, 0xD, 0x9, 0x6}, // 71: G
    {0x9, 0x9, 0xF, 0x9, 0x9, 0x9}, // 72: H
    {0xE, 0x4, 0x4, 0x4, 0x4, 0xE}, // 73: I
    {0xE, 0x4, 0x4, 0x4, 0x5, 0x2}, // 74: J
    {0x9, 0x5, 0x3, 0x5, 0x9, 0x9}, // 75: K
    {0x1, 0x1, 0x1, 0x1, 0x1, 0xF}, // 76: L
    {0x9, 0xF, 0xF, 0x9, 0x9, 0x9}, // 77: M
    {0x9, 0xB, 0xD, 0x9, 0x9, 0x9}, // 78: N
    {0x6, 0x9, 0x9, 0x9, 0x9, 0x6}, // 79: O
    {0x7, 0x9, 0x9, 0x7, 0x1, 0x1}, // 80: P
    {0x6, 0x9, 0x9, 0xD, 0x5, 0xA}, // 81: Q
    {0x7, 0x9, 0x7, 0x5, 0x9, 0x9}, // 82: R
    {0x6, 0x9, 0x6, 0x8, 0x9, 0x6}, // 83: S
    {0xE, 0x4, 0x4, 0x4, 0x4, 0x4}, // 84: T
    {0x9, 0x9, 0x9, 0x9, 0x9, 0x6}, // 85: U
    {0x9, 0x9, 0x9, 0x9, 0x6, 0x6}, // 86: V
    {0x9, 0x9, 0x9, 0xF, 0xF, 0x9}, // 87: W
    {0x9, 0x9, 0x6, 0x6, 0x9, 0x9}, // 88: X
    {0x9, 0x9, 0x6, 0x4, 0x4, 0x4}, // 89: Y
    {0xF, 0x8, 0x4, 0x2, 0x1, 0xF}, // 90: Z
    {0x6, 0x2, 0x2, 0x2, 0x2, 0x6}, // 91: [
    {0x1, 0x2, 0x2, 0x4, 0x4, 0x8}, // 92: backslash
    {0x6, 0x4, 0x4, 0x4, 0x4, 0x6}, // 93: ]
    {0x4, 0xA, 0x0, 0x0, 0x0, 0x0}, // 94: ^
    {0x0, 0x0, 0x0, 0x0, 0x0, 0xF}, // 95: _
    {0x2, 0x4, 0x0, 0x0, 0x0, 0x0}, // 96: `
    {0x0, 0x6, 0x8, 0xE, 0x9, 0xE}, // 97: a
    {0x1, 0x1, 0x7, 0x9, 0x9, 0x7}, // 98: b
    {0x0, 0x6, 0x1, 0x1, 0x9, 0x6}, // 99: c
    {0x8, 0x8, 0xE, 0x9, 0x9, 0xE}, // 100: d
    {0x0, 0x6, 0x9, 0xF, 0x1, 0x6}, // 101: e
    {0x4, 0x2, 0x7, 0x2, 0x2, 0x2}, // 102: f
    {0x0, 0xE, 0x9, 0xE, 0x8, 0x6}, // 103: g
    {0x1, 0x1, 0x7, 0x9, 0x9, 0x9}, // 104: h
    {0x4, 0x0, 0x4, 0x4, 0x4, 0x4}, // 105: i
    {0x4, 0x0, 0x4, 0x4, 0x4, 0x3}, // 106: j
    {0x1, 0x9, 0x5, 0x3, 0x5, 0x9}, // 107: k
    {0x2, 0x2, 0x2, 0x2, 0x2, 0x4}, // 108: l
    {0x0, 0x5, 0xF, 0xF, 0x9, 0x9}, // 109: m
    {0x0, 0x7, 0x9, 0x9, 0x9, 0x9}, // 110: n
    {0x0, 0x6, 0x9, 0x9, 0x9, 0x6}, // 111: o
    {0x0, 0x7, 0x9, 0x7, 0x1, 0x1}, // 112: p
    {0x0, 0xE, 0x9, 0xE, 0x8, 0x8}, // 113: q
    {0x0, 0x7, 0x9, 0x1, 0x1, 0x1}, // 114: r
    {0x0, 0x6, 0x2, 0x4, 0x9, 0x6}, // 115: s
    {0x2, 0x7, 0x2, 0x2, 0x2, 0x4}, // 116: t
    {0x0, 0x9, 0x9, 0x9, 0x9, 0xE}, // 117: u
    {0x0, 0x9, 0x9, 0x9, 0x6, 0x6}, // 118: v
    {0x0, 0x9, 0x9, 0xF, 0xF, 0x6}, // 119: w
    {0x0, 0x9, 0x6, 0x6, 0x9, 0x9}, // 120: x
    {0x0, 0x9, 0x9, 0xE, 0x8, 0x6}, // 121: y
    {0x0, 0xF, 0x4, 0x2, 0x1, 0xF}, // 122: z
    {0x8, 0x4, 0x2, 0x4, 0x8, 0x0}, // 123: {
    {0x4, 0x4, 0x4, 0x4, 0x4, 0x4}, // 124: |
    {0x1, 0x2, 0x4, 0x2, 0x1, 0x0}, // 125: }
    {0x0, 0x2, 0x5, 0x4, 0x0, 0x0}, // 126: ~
};

// Simple 8x8 font (all printable ASCII characters 32-126)
static const uint8_t font_8x8[96][8] = {
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 32: Space
    {0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00}, // 33: !
    {0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 34: "
    {0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00}, // 35: #
    {0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00}, // 36: $
    {0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00}, // 37: %
    {0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00}, // 38: &
    {0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00}, // 39: '
    {0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00}, // 40: (
    {0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00}, // 41: )
    {0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00}, // 42: *
    {0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00}, // 43: +
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06}, // 44: ,
    {0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00}, // 45: -
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // 46: .
    {0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00}, // 47: /
    {0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00}, // 48: 0
    {0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00}, // 49: 1
    {0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00}, // 50: 2
    {0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00}, // 51: 3
    {0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00}, // 52: 4
    {0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00}, // 53: 5
    {0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00}, // 54: 6
    {0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00}, // 55: 7
    {0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00}, // 56: 8
    {0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00}, // 57: 9
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00}, // 58: :
    {0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06}, // 59: ;
    {0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00}, // 60: <
    {0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00}, // 61: =
    {0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00}, // 62: >
    {0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00}, // 63: ?
    {0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00}, // 64: @
    {0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00}, // 65: A
    {0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00}, // 66: B
    {0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00}, // 67: C
    {0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00}, // 68: D
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00}, // 69: E
    {0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00}, // 70: F
    {0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00}, // 71: G
    {0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00}, // 72: H
    {0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 73: I
    {0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00}, // 74: J
    {0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00}, // 75: K
    {0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00}, // 76: L
    {0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00}, // 77: M
    {0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00}, // 78: N
    {0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00}, // 79: O
    {0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00}, // 80: P
    {0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00}, // 81: Q
    {0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00}, // 82: R
    {0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00}, // 83: S
    {0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 84: T
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00}, // 85: U
    {0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // 86: V
    {0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}, // 87: W
    {0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00}, // 88: X
    {0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00}, // 89: Y
    {0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00}, // 90: Z
    {0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00}, // 91: [
    {0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00}, // 92: backslash
    {0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00}, // 93: ]
    {0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00}, // 94: ^
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF}, // 95: _
    {0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00}, // 96: `
    {0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00}, // 97: a
    {0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00}, // 98: b
    {0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00}, // 99: c
    {0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00}, // 100: d
    {0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00}, // 101: e
    {0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00}, // 102: f
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F}, // 103: g
    {0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00}, // 104: h
    {0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 105: i
    {0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E}, // 106: j
    {0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00}, // 107: k
    {0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00}, // 108: l
    {0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00}, // 109: m
    {0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00}, // 110: n
    {0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00}, // 111: o
    {0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F}, // 112: p
    {0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78}, // 113: q
    {0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00}, // 114: r
    {0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00}, // 115: s
    {0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00}, // 116: t
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00}, // 117: u
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00}, // 118: v
    {0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00}, // 119: w
    {0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00}, // 120: x
    {0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F}, // 121: y
    {0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00}, // 122: z
    {0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00}, // 123: {
    {0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00}, // 124: |
    {0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00}, // 125: }
    {0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, // 126: ~
};

void display_draw_char(uint8_t x, uint8_t y, char c, spud_color_t color, spud_color_t bg_color) {
    if(c < 32 || c > 126) c = 32; // Default to space for unsupported chars

    const uint8_t* char_data = font_8x8[c - 32];

    for(int py = 0; py < 8; py++) {
        uint8_t row = char_data[py];
        for(int px = 0; px < 8; px++) {
            // Fixed: Read bits from left to right (bit 0 is leftmost)
            spud_color_t pixel_color = (row & (1 << px)) ? color : bg_color;
            if(x + px < DISPLAY_WIDTH && y + py < DISPLAY_HEIGHT) {
                display_set_pixel(x + px, y + py, pixel_color);
            }
        }
    }
}

void display_draw_string(uint8_t x, uint8_t y, const char* str, spud_color_t color, spud_color_t bg_color) {
    uint8_t cx = x;
    uint8_t cy = y;

    for(int i = 0; str[i] != '\0'; i++) {
        if(str[i] == '\n') {
            cx = x;
            cy += 8;
            if(cy >= DISPLAY_HEIGHT) break;
            continue;
        }

        display_draw_char(cx, cy, str[i], color, bg_color);
        cx += 8;

        if(cx >= DISPLAY_WIDTH) {
            cx = x;
            cy += 8;
            if(cy >= DISPLAY_HEIGHT) break;
        }
    }
}

// Scaled character drawing
void display_draw_char_scaled(uint8_t x, uint8_t y, char c, spud_color_t color, spud_color_t bg_color, uint8_t scale) {
    if(c < 32 || c > 126) c = 32; // Default to space for unsupported chars
    if(scale == 0) scale = 1;

    const uint8_t* char_data = font_8x8[c - 32];

    for(int py = 0; py < 8; py++) {
        uint8_t row = char_data[py];
        for(int px = 0; px < 8; px++) {
            spud_color_t pixel_color = (row & (1 << px)) ? color : bg_color;

            // Draw scaled pixel (scale x scale block)
            for(int sy = 0; sy < scale; sy++) {
                for(int sx = 0; sx < scale; sx++) {
                    uint8_t draw_x = x + px * scale + sx;
                    uint8_t draw_y = y + py * scale + sy;
                    if(draw_x < DISPLAY_WIDTH && draw_y < DISPLAY_HEIGHT) {
                        display_set_pixel(draw_x, draw_y, pixel_color);
                    }
                }
            }
        }
    }
}

void display_draw_string_scaled(uint8_t x, uint8_t y, const char* str, spud_color_t color, spud_color_t bg_color, uint8_t scale) {
    if(scale == 0) scale = 1;
    uint8_t cx = x;
    uint8_t cy = y;
    uint8_t char_width = 8 * scale;
    uint8_t char_height = 8 * scale;

    for(int i = 0; str[i] != '\0'; i++) {
        if(str[i] == '\n') {
            cx = x;
            cy += char_height;
            if(cy >= DISPLAY_HEIGHT) break;
            continue;
        }

        display_draw_char_scaled(cx, cy, str[i], color, bg_color, scale);
        cx += char_width;

        if(cx >= DISPLAY_WIDTH) {
            cx = x;
            cy += char_height;
            if(cy >= DISPLAY_HEIGHT) break;
        }
    }
}

// Convert RGB565 color to closest standard SpudKit color
spud_color_t display_map_rgb565_to_palette(uint16_t color_565) {
    // Extract RGB components from RGB565
    uint8_t r5 = (color_565 >> 11) & 0x1F;
    uint8_t g6 = (color_565 >> 5) & 0x3F;
    uint8_t b5 = color_565 & 0x1F;

    // Convert to 8-bit values
    uint8_t r = (r5 * 255) / 31;
    uint8_t g = (g6 * 255) / 63;
    uint8_t b = (b5 * 255) / 31;

    // Calculate brightness and color characteristics
    uint16_t brightness = r + g + b;

    // Map to closest color from the standard palette
    // Check for grayscale colors first
    if (r > 200 && g > 200 && b > 200) {
        return COLOR_WHITE;  // Very dark
    } else if (r < 50 && g < 50 && b < 50) {
        return COLOR_BLACK;  // Very light
    }

    // Check for chromatic colors
    // Find which component is dominant
    if (r > g && r > b) {
        // Red dominant
        if (g > b + 30) {
            return COLOR_YELLOW;  // Red + Green = Yellow
        } else if (b > g + 30) {
            return COLOR_MAGENTA;  // Red + Blue = Magenta
        } else {
            return COLOR_RED;
        }
    } else if (g > r && g > b) {
        // Green dominant
        if (r > b + 30) {
            return COLOR_YELLOW;  // Green + Red = Yellow
        } else if (b > r + 30) {
            return COLOR_CYAN;  // Green + Blue = Cyan
        } else {
            return COLOR_GREEN;
        }
    } else if (b > r && b > g) {
        // Blue dominant
        if (r > g + 30) {
            return COLOR_MAGENTA;  // Blue + Red = Magenta
        } else if (g > r + 30) {
            return COLOR_CYAN;  // Blue + Green = Cyan
        } else {
            return COLOR_BLUE;
        }
    }

    // If roughly equal components, map by brightness
    if (brightness > 400) {
        return COLOR_WHITE;
    } else if (brightness > 200) {
        return COLOR_CYAN;  // Medium gray -> cyan as fallback
    } else {
        return COLOR_BLACK;
    }
}

// 4x6 small font drawing functions
void display_draw_char_small(uint8_t x, uint8_t y, char c, spud_color_t color, spud_color_t bg_color) {
    if(c < 32 || c > 126) c = 32; // Default to space for unsupported chars

    const uint8_t* char_data = font_4x6[c - 32];

    for(int py = 0; py < 6; py++) {
        uint8_t row = char_data[py];
        for(int px = 0; px < 4; px++) {
            // Read bits from left to right (bit 0 is leftmost)
            spud_color_t pixel_color = (row & (1 << px)) ? color : bg_color;
            if(x + px < DISPLAY_WIDTH && y + py < DISPLAY_HEIGHT) {
                display_set_pixel(x + px, y + py, pixel_color);
            }
        }
    }
}

void display_draw_string_small(uint8_t x, uint8_t y, const char* str, spud_color_t color, spud_color_t bg_color) {
    uint8_t cx = x;
    uint8_t cy = y;

    for(int i = 0; str[i] != '\0'; i++) {
        if(str[i] == '\n') {
            cx = x;
            cy += 6;
            if(cy >= DISPLAY_HEIGHT) break;
            continue;
        }

        display_draw_char_small(cx, cy, str[i], color, bg_color);
        cx += 5;  // 4 pixels + 1 spacing

        if(cx >= DISPLAY_WIDTH) {
            cx = x;
            cy += 6;
            if(cy >= DISPLAY_HEIGHT) break;
        }
    }
}

void display_update(void) {
#if defined(SIM_DISPLAY) || defined(UART_DISPLAY)
    DISPLAY_PUTS("DISPLAY_UPDATE: Refreshing display\r\n");
    display_sim_print_buffer();
#else
    // Transfer framebuffer to actual 64x64 matrix display
    volatile uint32_t* display_data_reg = (volatile uint32_t*)SPUD_DISPLAY_PIXEL_DATA_REG;
    volatile uint32_t* display_addr_reg = (volatile uint32_t*)SPUD_DISPLAY_PIXEL_ADDR_REG;

    for(int y = 0; y < DISPLAY_HEIGHT; y++) {
        for(int x = 0; x < DISPLAY_WIDTH; x++) {
            uint16_t pixel_addr = y * DISPLAY_WIDTH + x;

            // framebuffer already contains RGB888 colors for real hardware, no conversion needed
            // Write address and data to display controller
            *display_addr_reg = pixel_addr;
            *display_data_reg = framebuffer[y][x];
        }
    }
#endif
}
